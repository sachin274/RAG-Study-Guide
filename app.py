"""
Flask Backend - With Gemini Integration (No Auto-Cleanup)
"""

import sys
import os

# Fix for asyncio event loop issues on Windows with Flask
if sys.platform == 'win32':
    import asyncio
    asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())

from flask import Flask, request, jsonify, send_file, render_template
from flask_cors import CORS
from werkzeug.utils import secure_filename
import os
from datetime import datetime
import traceback

# Import the RAG pipeline, Gemini generator, and PDF converter
from main_rag import RAGPipeline
from gemini_generator import generate_study_content_with_gemini
from pdf_converter import convert_markdown_to_pdf

app = Flask(__name__)
CORS(app)

# Configuration
UPLOAD_FOLDER = 'uploads'
OUTPUT_FOLDER = 'outputs'
EXTRACTED_TEXT_FOLDER = 'extracted_text'
VECTOR_STORE_FOLDER = 'faiss_stores'
ALLOWED_EXTENSIONS = {'pdf', 'docx', 'txt'}
MAX_FILE_SIZE = 50 * 1024 * 1024  # 50MB

# Create necessary folders
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(OUTPUT_FOLDER, exist_ok=True)
os.makedirs(EXTRACTED_TEXT_FOLDER, exist_ok=True)
os.makedirs(VECTOR_STORE_FOLDER, exist_ok=True)

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['OUTPUT_FOLDER'] = OUTPUT_FOLDER
app.config['EXTRACTED_TEXT_FOLDER'] = EXTRACTED_TEXT_FOLDER
app.config['VECTOR_STORE_FOLDER'] = VECTOR_STORE_FOLDER
app.config['MAX_CONTENT_LENGTH'] = MAX_FILE_SIZE


def allowed_file(filename):
    """Check if file extension is allowed"""
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS


def create_study_guide_markdown_with_gemini(gemini_content, metadata, output_path):
    """
    Create a markdown study guide using Gemini-generated content
    
    Args:
        gemini_content: Content generated by Gemini API
        metadata: Dict with processing metadata
        output_path: Where to save the markdown file
    """
    
    # Create markdown formatted content
    content = []
    
    # Title
    content.append("# AI Generated Study Guide\n")
    content.append("=" * 80)
    content.append("\n\n")
    
    # Metadata section
    content.append("## Document Information\n\n")
    content.append(f"- **Source File:** {metadata.get('source_file', 'N/A')}\n")
    content.append(f"- **Topics Requested:** {metadata.get('topics', 'N/A')}\n")
    content.append(f"- **Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
    content.append(f"- **Total Chunks Analyzed:** {metadata.get('total_chunks', 'N/A')}\n")
    content.append(f"- **Relevant Sections Found:** {metadata.get('relevant_count', 'N/A')}\n")
    content.append(f"- **Generated with:** Google Gemini Pro\n")
    content.append("\n" + "=" * 80 + "\n\n")
    
    # Main Study Content (from Gemini)
    content.append("## Study Content\n\n")
    content.append(gemini_content)
    content.append("\n\n")
    
    # Footer
    content.append("\n\n")
    content.append("---\n\n")
    content.append("## Study Tips\n\n")
    content.append("- Review each section thoroughly\n")
    content.append("- Make notes of key concepts\n")
    content.append("- Test yourself on the material\n")
    content.append("- Create flashcards for important terms\n")
    content.append("- Practice recalling information without looking at notes\n\n")
    content.append("---\n\n")
    content.append("*Generated by AI-Powered RAG Study Planner*\n")
    content.append("*Powered by Google Gemini Pro & FAISS Vector Store*\n")
    
    # Write to file
    with open(output_path, 'w', encoding='utf-8') as f:
        f.writelines(content)
    
    print(f"[Flask] Study guide created: {output_path}")


@app.route("/")
def serve_frontend():
    return render_template("index.html")

@app.route('/api/generate', methods=['POST'])
def generate_study_guide():
    """
    Main endpoint to generate study guide with Gemini integration
    """
    try:
        print("\n" + "="*80)
        print("[Flask] New study guide generation request")
        print("="*80)
        
        # Validate request
        if 'file' not in request.files:
            return jsonify({'error': 'No file uploaded'}), 400
        
        if 'topics' not in request.form:
            return jsonify({'error': 'No topics specified'}), 400
        
        file = request.files['file']
        topics = request.form['topics']
        
        # Optional: Get custom prompt if provided
        custom_prompt = request.form.get('custom_prompt', None)
        
        print(f"[Flask] Topics: {topics}")
        
        # Validate file
        if file.filename == '':
            return jsonify({'error': 'No file selected'}), 400
        
        if not allowed_file(file.filename):
            return jsonify({'error': 'Invalid file type. Only PDF, DOCX, and TXT are allowed'}), 400
        
        # Save uploaded file
        filename = secure_filename(file.filename)
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        unique_filename = f"{timestamp}_{filename}"
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], unique_filename)
        file.save(file_path)
        
        print(f"[Flask] File saved: {file_path}")
        
        # Initialize RAG pipeline
        print("[Flask] Initializing RAG pipeline...")
        pipeline = RAGPipeline()
        
        # Set up vector store directory
        vector_store_path = os.path.join(
            app.config['VECTOR_STORE_FOLDER'], 
            f"vs_{timestamp}"
        )
        
        # Process document with RAG pipeline
        # Only keep document text that is at least 50% relevant to the topics.
        # Higher value = stricter matching
        # Lower value = more results

        print("[Flask] Processing document with RAG pipeline...")
        result = pipeline.process_document(
            file_path=file_path,
            topics=topics,
            extracted_text_folder=app.config['EXTRACTED_TEXT_FOLDER'],
            persist_directory=vector_store_path,
            similarity_threshold=0.5
        )
        
        if not result['success']:
            raise Exception("RAG pipeline processing failed")
        
        print(f"[Flask] RAG processing complete")
        print(f"[Flask] Total chunks: {result['total_chunks']}")
        print(f"[Flask] Relevant chunks: {result['relevant_count']}")
        
        # Check if we have relevant chunks
        if result['relevant_count'] == 0:
            return jsonify({
                'error': 'No relevant content found for the specified topics. Try different keywords or broader topics.'
            }), 400
        
        # Generate content with Gemini
        print("[Flask] Generating study content with Gemini API...")
        gemini_content = generate_study_content_with_gemini(
            relevant_chunks=result['relevant_chunks'],
            topics=topics,
            custom_prompt=custom_prompt  # Pass custom prompt if provided
        )
        print("[Flask] Gemini content generation complete")
        
        # Create markdown study guide with Gemini content (temporary)
        output_filename_md = f"study_guide_{timestamp}.md"
        output_path_md = os.path.join(app.config['OUTPUT_FOLDER'], output_filename_md)
        
        print("[Flask] Creating temporary markdown file...")
        create_study_guide_markdown_with_gemini(
            gemini_content=gemini_content,
            metadata={
                'topics': topics,
                'source_file': filename,
                'total_chunks': result['total_chunks'],
                'relevant_count': result['relevant_count']
            },
            output_path=output_path_md
        )
        
        # Convert markdown to PDF
        print("[Flask] Converting markdown to PDF...")
        output_filename_pdf = f"study_guide_{timestamp}.pdf"
        output_path_pdf = os.path.join(app.config['OUTPUT_FOLDER'], output_filename_pdf)
        
        pdf_result = convert_markdown_to_pdf(
            markdown_file=output_path_md,
            output_pdf=output_path_pdf,
            metadata={
                'title': f'Study Guide: {topics}',
                'author': 'AI Study Planner',
                'date': datetime.now().strftime('%B %d, %Y')
            }
        )
        
        if not pdf_result['success']:
            # If PDF conversion fails, return markdown file instead
            print(f"[Flask] ⚠️ PDF conversion failed: {pdf_result['error']}")
            print(f"[Flask] Returning markdown file instead")
            
            return jsonify({
                'success': True,
                'message': 'Study guide generated (PDF conversion unavailable, returning markdown)',
                'filename': output_filename_md,
                'download_url': f'/api/download/{output_filename_md}',
                'chunks_processed': result['total_chunks'],
                'relevant_chunks': result['relevant_count'],
                'warning': pdf_result['error']
            }), 200
        
        # PDF conversion successful - remove temporary markdown file
        try:
            os.remove(output_path_md)
            print(f"[Flask] Removed temporary markdown file")
        except:
            pass
        
        print(f"[Flask] Study guide PDF generated successfully: {output_filename_pdf}")
        print("="*80 + "\n")
        
        # Return success response
        return jsonify({
            'success': True,
            'message': 'Study guide PDF generated successfully with AI',
            'filename': output_filename_pdf,
            'download_url': f'/api/download/{output_filename_pdf}',
            'chunks_processed': result['total_chunks'],
            'relevant_chunks': result['relevant_count']
        }), 200
        
    except Exception as e:
        print(f"[Flask ERROR] {str(e)}")
        traceback.print_exc()
        return jsonify({'error': f'Server error: {str(e)}'}), 500


@app.route('/api/download/<filename>', methods=['GET'])
def download_file(filename):
    """Endpoint to download generated study guide"""
    try:
        file_path = os.path.join(app.config['OUTPUT_FOLDER'], secure_filename(filename))
        
        if not os.path.exists(file_path):
            return jsonify({'error': 'File not found'}), 404
        
        return send_file(
            file_path,
            as_attachment=True,
            download_name=filename,
            mimetype='application/pdf' if filename.endswith('.pdf') else 'text/markdown'
        )
        
    except Exception as e:
        print(f"[Flask ERROR] Download error: {str(e)}")
        return jsonify({'error': f'Download failed: {str(e)}'}), 500


@app.route('/api/health', methods=['GET'])
def health_check():
    """Health check endpoint"""
    return jsonify({
        'status': 'healthy',
        'message': 'RAG Study Guide API is running',
        'mode': 'Study Material with Gemini AI',
        'using': 'Google Gemini Pro + FAISS Vector Store'
    }), 200


if __name__ == '__main__':
    print("\n" + "=" * 80)
    print("RAG STUDY GUIDE BACKEND STARTING...")
    print("=" * 80)
    print(f"Upload folder: {os.path.abspath(UPLOAD_FOLDER)}")
    print(f"Output folder: {os.path.abspath(OUTPUT_FOLDER)}")
    print(f"Extracted text folder: {os.path.abspath(EXTRACTED_TEXT_FOLDER)}")
    print(f"Vector store folder: {os.path.abspath(VECTOR_STORE_FOLDER)}")
    print(f"Mode: Study Material with AI Generation")
    print(f"Using: Google Gemini Pro + FAISS Embeddings")
    print(f"Frontend available at: http://localhost:5000")
    print("=" * 80 + "\n")
    
    app.run(debug=True, host='0.0.0.0', port=5000, threaded=True, use_reloader=False)